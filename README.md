##  Копырина Полина Ивановна, группа БПИ213   
#   Индивидуальное домашнее задание №1. Вариант 14.

## Задание:
###    Разработать программу, вычисляющую отдельно число прописных и строчных букв в заданной ASCII-строке.

##  4 балла

### **Программа на языке Си**

**Файл code.c содержит решение задачи на языке Си на 8 баллов.**

В программе реализованы:
1. Функция для ввода строки из файла (строка заканчивается EOF)
  > char *read_string(char *file_name);
2. Функция для вывода строки в файл
>  void write_string(char *str, char *file_name);
3. Функция для генерации строки заданного размера с помощью рандома
> char *random_string(size_t size)
4. Функция для подсчета количества прописных букв в строке
> unsigned int count_uppercase(char *str)
5. Функция для подсчета количества строчных букв в строке
> unsigned int count_lowercase(char *str)
6. Функция для вывода результатов с подсчитанным количеством букв в файл
> void write_result(unsigned int uppercase, unsigned int lowercase, char *file_name)
7. Функция для освобождения динамической памяти, выделенной под строку
> void free_memory(char *str)
8. Функция main
> int main(int argc, char **argv)

Память для строки выделяется динамически. 

***

### **Запуск исполняемого файла** 

Для получения исполняемого файла в терминале выполняем команду:
> gcc code.c -o code

Передача аргументов в программу осуществляется через командную строку.
Для корректной работы программы необходимо передать имя файла с входными данными в качестве **первого** аргумента, а также
имя файла для вывода данных в качестве **второго** аргумента.

Пример запуска исполняемого файла:
> ./code input.txt output.txt

В программе предоставлена опция сгенерировать входную строку, не считывая её из входного файла.
Для этого надо прописать опцию **_--rand_** и следом за ней указать размер генерируемой строки. Если размер строки не указан, то размер генерируемой строки равен 1000 по умолчанию.

Сгенерированная строка выводится в файл, указанный в качестве файла с входными данными, то есть указанный в качестве первого аргумента при запуске программы (для того, чтобы у пользователя был доступ к сгенерированной строке и для генерации рандомных тестов, что расширяет возможности тестирования).

Пример запуска программы с генерацией рандомной строки:
> ./code input.txt output.txt --rand

В данном случае программа сгенерирует строку размером 1000 и выведет её в _input.txt_. В файл
_output.txt_ будет выведено количество прописных и строчных букв в сгенерированной строке соответственно.

> ./code input.txt output.txt --rand 200

В данном случае программа сгенерирует строку размером 200 и выведет её в _input.txt_.  В файл
_output.txt_ будет выведено количество прописных и строчных букв в сгенерированной строке соответственно.

Также предусмотрена возможность замера времени исполнения той части программы, которая выполняет вычисления
(имеется в виду выполнение функции _count_lowercase_ и _count_uppercase_). При замере времени этот блок зацикливается 500 раз, чтобы сделать разницу во времени нагляднее.

Для замера времени нужно при запуске программы добавить опцию **_--time_**. Результат замера времени будет выведен в консоль.

Пример запуска программы с замером времени:
> ./code input.txt output.txt --time

Рандомную генерацию массива и замеры времени можно совмещать:
> ./code input.txt output.txt --rand 5000 --time

***

### **Компиляция в ассемблер**

С помощью gcc получим программу на языке ассемблера из нашего решения на языке Си.
Для этого введем в терминал следующую команду:
  
  > **gcc -O0 -Wall -masm=intel -S -fno-asynchronous-unwind-tables -fcf-protection=none code.c -o code.s**
  
За счет использования вышеперечисленных аргументов командной строки наша программа станет более компактной,
так как будут убраны лишние макросы.

**В файле _code.s_ содержится программа на языке ассемблера, полученная с помощью команды, приведенной выше, с комментариями, поясняющими эквивалентное представление кода в программе на языке Си (code.c), а также передачу фактических параметров и перенос возвращаемого результата при вызове функций.**

Для получения исполняемого файла из ассемблерной программы необходимо выполнить в терминале команду.
> gcc code.s -o asm_code

Исполняемый файл из ассемблерной программы запускается точно так же, как и исполняемый файл, полученный из программы на Си. Более подробная инфорация о формате команды для запуска программы содержится в разделе "Запуск исполняемого файла".

***
### **Тестирование**

Все тесты лежат в папке **testing/tests**. Часть тестов была создана вручную, часть была создана с помощью возможности генерации рандомной строки в написанной программе.
Так же был создан скрипт на Python **createTests.py**, который автоматизирует создание нескольких тестов (нужно указать, сколько тестов уже создано, сколько нужно создать и размер генерируемой строки)

Результаты тестирования программы на Си (code.c) лежат в папке **testing/results/c**

Результаты тестирования программы на ассемблере, полученной компилятором(code.s) лежат в папке **testing/results/asm**

Результаты тестирования оптимизированной программы на ассемблере(/optimized) лежат в папке **testing/results/optimized**

Также был создан скрипт на Python **runTests.py**, который прогоняет все тесты из папки testing/tests на всех трех вариантах программ.

Для проверки того, что результаты всех тестов совпадают и программы работают одинаково можно использовать скрипт **checkTests.py** - при запуске он выводит вердикт для каждого теста.

***


##  5 баллов
Программа на ассемблере подробно прокомментирована, поясняется почти каждая операция. В программе используются локальные переменные (на ассемблере они хранятся либо на стеке, либо в регистрах). Данные в функции передаются через параметры.

***
## 6 баллов
### **Рефакторинг ассемблерной программы**
  
В папке **optimized** содержатся ассемблерные файлы, полученные после рефакторинга ассемблерной программы за счет максимального использования регистров процессора.

При рефакторинге программа была разбита на три единицы компиляции: 
1. fileStreams.s - тут находятся функции, связанные с вводом/выводом в файлы:
    - read_string
    - write_string
    - write_result
2.  countLetters.s - тут находятся функции, отвечающие за подсчет строчных и прописных букв:
    - count_uppercase
    - count_lowercase
3.  main.s - тут находятся все остальные функции (в основном отвечающие за обработку опций): 
    - random_string
    - main

Описание функций можно посмотреть в разделе "Программа на языке Си".
Все ассемблерные файлы содержат комментарии, поясняющие связь между ассемблерной программой и программой на языке си (а так же сам ход ассемблерной программы).

Запустив скрипт **checkTests.py** в папке testing можно убедиться, что оптимизированная программа работает корректно и результаты тестов совпадают.

Давайте сравним размеры полученных ассемблерных программ:
- Программа в code.s вместе со всеми комментариями и отступами занимает 660 строк.
- Оптимизированная программа занимает примерно 595 строк (countLetters.s: 84 строки, fileStreams.s: 190 строк, main.s: 320 строк).
Выигрыш в размере составляет около 65 строк, то есть оптимизированная программа на 10% меньше по объему программы, созданной gcc.

Для получения исполняемого файла необходимо запустить команду
> **gcc fileStreams.s countLetters.s main.s -o optimized**

## 7 баллов
Оптимизированная программа разделена на несколько единиц компиляции.

### Работа с файлами
В программе используются файлы для ввода/вывода данных. Информация о том, как работать с ними, содержится в разделе "Запуск исполняемого файла", но напишем об этом и здесь.

При запуске исполняемого файла необходимо передать как минимум 2 аргумента в командной строке:
1. Первый аргумент обязательно должен быть именем файла, в котором содержатся входные данные. При рандомной генерации строки сгенерированная строка как раз будет выведена в этот файл.
2. Второй по порядку аргумент обязательно должен быть именем файла, в который будет выведен результат работы программы.
Имена файлов должны быть заданы с учетом "вашего положения" в директории, откуда вы запускаете исполняемый файл.

Примеры см. в разделе "Запуск исполняемого файла".
Примеры входных/выходных файлов можно посмотреть в папке testing (там хранятся все тесты).

## 8 баллов

### Генератор случайной строки
Есть возможность случайно сгенерировать рандомные входные данные, добавив опцию "--rand" при запуске исполняемого файла.
Можно задать размер генерируемой строки, указав следующим аргументом целочисленное значение через пробел. Если размер строки не задан, то размером по умолчанию считается 1000.
Примеры запуска см. в разделе "Запуск исполняемого файла".

Стоит отметить, что при генерации строки использовались толкьо символы, имеющие код от 32 до 126 (эти символы без проблем и корректно отображаются в формате txt при просмотре).

### Замеры времени
Есть возможность измерить время работы программы. Для этого нужно указать опцию "--time" в командной строке (без дополнительных аргументов).
Тогда выполнение функций count_lowercase и count_uppercase зациклится 500 раз (для более наглядного результата).
Затраченное время будет выведено в консоли.

### Сравнение производительности

Сравним время работы оптимизированной программы и созданной компилятором.
Для этого запустим обе программы с опцией генерации строки размером 1000000 и опцией замера времени.

Для программы, созданной комплилятором
> ./code input.txt output.txt --rand 1000000 --time

Результаты замеров:
1. Process time: 4.016659 seconds
2. Process time: 4.004743 seconds
3. Process time: 4.036105 seconds

В среднем работа на данных размером 10^7 занимает 4.01916900 секунд.

Для оптимизированной программы
./optimized input.txt output.txt --rand 1000000 --time
1. Process time: 3.682439 seconds
2. Process time: 3.645906 seconds
3. Process time: 3.653610 seconds

Среднее время работы уже 3.6606516, что эффективнее на 10% не оптимизированной программы.